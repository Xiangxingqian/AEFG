//package analysis;
//
//import intent.InstanceSetting;
//
//import java.util.HashMap;
//import java.util.Iterator;
//import java.util.List;
//import java.util.Map;
//
//import entry.Entry;
//
//import soot.Local;
//import soot.Scene;
//import soot.SootClass;
//import soot.SootMethod;
//import soot.Type;
//import soot.Unit;
//import soot.Value;
//import soot.jimple.AssignStmt;
//import soot.jimple.CastExpr;
//import soot.jimple.Constant;
//import soot.jimple.DefinitionStmt;
//import soot.jimple.FieldRef;
//import soot.toolkits.graph.DirectedGraph;
//import util.ArrayUtil;
//import vasco.Context;
//import vasco.ProgramRepresentation;
//
//public class AEFGFieldInterproceduralAnalysis extends AEFGInterproceduralAnalysis<SootMethod, Unit, Map<FieldRef, List<Value>>>{
//
//	public AEFGFieldInterproceduralAnalysis(SootMethod m, List<Type> types,
//			int model) {
//		super(m, types, model);
//		// TODO Auto-generated constructor stub
//	}
//
//	static Map<SootClass, Map<FieldRef, List<Value>>> methodToFieldRef = new HashMap<SootClass, Map<FieldRef,List<Value>>>();
//
//
//	//1. 开始分析
//	@Override
//	public void doAnalysis() {
////		Context<SootMethod, Unit, Map<Local, List<Value>>> locals = getLocals(m);
////		Map<FieldRef, List<Value>> doFieldAnalysis = doFieldAnalysis(locals, m, types);
////		SootClass declaringClass = m.getDeclaringClass();
////		
////		if(methodToFieldRef.get(declaringClass)==null){
////			methodToFieldRef.put(declaringClass, doFieldAnalysis);
////		}
////		else{
////			Map<FieldRef, List<Value>> map = methodToFieldRef.get(declaringClass);
////			map = meet(map, doFieldAnalysis);
////		}
//	}
////	
////	/**
////	 * 2. 首先计算m中所有的locals信息。当field指向local时，可以将local的值赋值给field。
////	 * @param m Method is used to calculate locals' values. 
////	 * @return Context<SootMethod, Unit, Map<Local, List<Value>>> It means in the position unit, what the locals's values are.
////	 * */
////	public Context<SootMethod, Unit, Map<Local, List<Value>>> getLocals(SootMethod m){
////		AEFGForwordInterproceduralAnalysis forwordAnalysis = new AEFGForwordInterproceduralAnalysis(m);
////		return forwordAnalysis.doInterprocedure(m, 1, new HashMap<Local, List<Value>>(), null);
////	}
//	
//	/**
//	 * 3. 分析field信息
//	 * @param Context<SootMethod, Unit, Map<Local, List<Value>>> It means in the position unit, what the locals's values are.
//	 * @param method <init> or <clinit> method
//	 * @param types Target types we need to parse.
//	 * @return Map stored the values of field.
//	 * */
//	public Map<FieldRef, List<Value>> doFieldAnalysis(Context<SootMethod, Unit, Map<Local, List<Value>>> context, SootMethod method, List<Type> types){
//		DirectedGraph<Unit> controlFlowGraph = programRepresentation().getControlFlowGraph(method);
//		Iterator<Unit> iterator = controlFlowGraph.iterator();	
//		Map<FieldRef, List<Value>> output = topValue();
//		while(iterator.hasNext()){
//			Unit node = iterator.next();
//			Map<Local, List<Value>> input = context.getValueBefore(node);
//			if(isAssignStmt(node)){
//				AssignStmt as = (AssignStmt)node;
//				Value leftOp = as.getLeftOp();
//				if(leftOp instanceof FieldRef){
//					if(isCall(node)){
//						System.err.println("Error happens in "+ AEFGFieldInterproceduralAnalysis.class+" Node is: "+node);
//					}
//					else{
//						Value rhs = as.getRightOp();
//						output = parseLeftOp((FieldRef)leftOp, rhs, input, output);
//					}
//				}
//			}
//		}
//		return output;
//	}
//	
//	/**
//	 * 4. 求field的值
//	 * @param lhs SootField ref to be assigned value
//	 * @param rhs A variety of types representing SootField. The types can be constant, castExpr, local. 
//	 * @param input A map records the values of locals. If field points to a local, field = input.get(local).
//	 * @param output A map to receive the SootField to Values. 
//	 * @return output values of Field.
//	 * */
//	public Map<FieldRef, List<Value>> parseLeftOp(FieldRef lhs, Value rhs, Map<Local, List<Value>> input,Map<FieldRef, List<Value>> output){
//		if (rhs instanceof CastExpr) {
//			rhs = ((CastExpr) rhs).getOp();
//		}
//		if (rhs instanceof Constant) {
//			// If RHS is a constant, it is a direct gen
//			output.put(lhs, ArrayUtil.toList(rhs));
//		} 
//		// Then check if the RHS operand is a constant or local
//		else if (rhs instanceof Local) {
//			// Copy constant-status of RHS to LHS (indirect gen), if exists
//			if(input.containsKey(rhs)) {
//				output.put(lhs, input.get(rhs));
//			}
//		} 
//		return output;
//	}
//	
//	
//	//-----------------------------------------------------------------------------------------以下方法都未被使用
//	@Override
//	public Map<FieldRef, List<Value>> normalFlowFunction(
//			Context<SootMethod, Unit, Map<FieldRef, List<Value>>> context,
//			Unit unit, Map<FieldRef, List<Value>> inValue) {
//		// Initialize result to input
//		Map<FieldRef, List<Value>> outValue = copy(inValue);
//		// Only statements assigning locals matter
//		if (unit instanceof AssignStmt) {
//			// Get operands
//			Value lhsOp = ((AssignStmt) unit).getLeftOp();
//			Value rhsOp = ((AssignStmt) unit).getRightOp();
//			if (lhsOp instanceof FieldRef) {
//				assign((FieldRef) lhsOp, rhsOp, inValue, outValue);		
//			}
//		} 
//		return outValue;
//	}
//
//	private void assign(FieldRef lhs, Value rhs,
//			Map<FieldRef, List<Value>> input,
//			Map<FieldRef, List<Value>> output) {
//		// First remove casts, if any.
//		if (rhs instanceof CastExpr) {
//			rhs = ((CastExpr) rhs).getOp();
//		}
//		if (rhs instanceof Constant) {
//			// If RHS is a constant, it is a direct gen
//			output.put(lhs, ArrayUtil.toList(rhs));
//		} 
//		// Then check if the RHS operand is a constant or local
//		else if (rhs instanceof Local) {
//			// Copy constant-status of RHS to LHS (indirect gen), if exists
//			if(input.containsKey(rhs)) {
//				output.put(lhs, input.get(rhs));
//			}
//		} else {
//			// RHS is some compound expression, then LHS is non-constant (only kill)
//			output.put(lhs, null);
//		}			
//	}
//
//
//	@Override
//	public Map<FieldRef, List<Value>> boundaryValue(SootMethod entryPoint) {
//		return topValue();
//	}
//
//	@Override
//	public Map<FieldRef, List<Value>> copy(Map<FieldRef, List<Value>> src) {
//		return new HashMap<FieldRef, List<Value>>(src);
//	}
//
//	@Override
//	public Map<FieldRef, List<Value>> meet(Map<FieldRef, List<Value>> op1,
//			Map<FieldRef, List<Value>> op2) {
//		Map<FieldRef, List<Value>> result = new HashMap<FieldRef, List<Value>>(op1);
//		// Then add everything in the second operand, bottoming out the common keys with different values
//		for (FieldRef x : op2.keySet()) {
//			if (op1.containsKey(x)) {
//				// Check the values in both operands
//				List<Value> c1 = op1.get(x);
//				List<Value> c2 = op2.get(x);
//				if (c1 != null && c1.equals(c2) == false) {
//					// Set to non-constant
//					c1.addAll(c2);
//					result.put(x, c1);
//				}
//			} else {
//				// Only in second operand, so add as-is
//				result.put(x, op2.get(x));
//			}
//		}
//		return result;
//	}
//
//	@Override
//	public ProgramRepresentation<SootMethod, Unit> programRepresentation() {
//		return new AEFGDefaultProgramRepresentation(m, Entry.getCallGraph());
//	}
//
//	@Override
//	public Map<FieldRef, List<Value>> topValue() {
//		return new HashMap<FieldRef, List<Value>>();
//	}
//	
//	public Map<SootClass, Map<FieldRef, List<Value>>> getMethodToFieldRef() {
//		return methodToFieldRef;
//	}
//	
//	
//	//-----------------------------------------------------------------------------以下方法不使用
//	
//	@Override
//	public Map<FieldRef, List<Value>> callEntryFlowFunction(
//			Context<SootMethod, Unit, Map<FieldRef, List<Value>>> context,
//			SootMethod targetMethod, Unit node,
//			Map<FieldRef, List<Value>> inValue) {
//		// TODO Auto-generated method stub
//		return null;
//	}
//
//	@Override
//	protected SootMethod resolveMethod(Unit node) {
//		// TODO Auto-generated method stub
//		return null;
//	}
//
//	@Override
//	protected boolean isAnalyzedType(DefinitionStmt ds, List<Type> types) {
//		// TODO Auto-generated method stub
//		return false;
//	}
//
//	@Override
//	protected Map<FieldRef, List<Value>> computeMethodDefinition(
//			Context<SootMethod, Unit, Map<FieldRef, List<Value>>> currentContext,
//			Unit node, Map<FieldRef, List<Value>> in) {
//		// TODO Auto-generated method stub
//		return null;
//	}
//
//	@Override
//	protected Map<FieldRef, List<Value>> computeEntry(
//			Context<SootMethod, Unit, Map<FieldRef, List<Value>>> currentContext,
//			Unit node, Map<FieldRef, List<Value>> in) {
//		// TODO Auto-generated method stub
//		return null;
//	}
//
//	@Override
//	public boolean isTargetMethod(SootMethod m, List<Type> types) {
//		// TODO Auto-generated method stub
//		return false;
//	}
//
//	@Override
//	public boolean isApplicationMethod(SootMethod m) {
//		// TODO Auto-generated method stub
//		return false;
//	}
//}
