package com.app.test;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import soot.Body;
import soot.BodyTransformer;
import soot.BooleanType;
import soot.G;
import soot.Local;
import soot.Modifier;
import soot.PackManager;
import soot.PatchingChain;
import soot.Scene;
import soot.SootClass;
import soot.SootField;
import soot.SootMethod;
import soot.Transform;
import soot.Type;
import soot.Unit;
import soot.Value;
import soot.jimple.AbstractStmtSwitch;
import soot.jimple.AssignStmt;
import soot.jimple.GotoStmt;
import soot.jimple.IdentityStmt;
import soot.jimple.IfStmt;
import soot.jimple.IntConstant;
import soot.jimple.InvokeExpr;
import soot.jimple.InvokeStmt;
import soot.jimple.Jimple;
import soot.jimple.ReturnVoidStmt;
import soot.jimple.internal.JNewExpr;
import soot.util.Chain;

import com.app.test.newClass.FinishThread;
import com.app.test.newClass.TestThread;
import com.app.test.newMethod.CheckEvent;
import com.app.test.newMethod.CheckEventForMainActivity;
import com.app.test.newMethod.Clinit;
import com.app.test.newMethod.DoReflect;
import com.app.test.newMethod.DoTest;
import com.app.test.newMethod.OnRestart;
import com.app.test.newMethod.RunMyThread;

public class AndroidInstrument{
	
	public void instrument(String[] args){
        transform(args);
	}
	
	public void transform(String[] args){
		PackManager.v().getPack("jtp").add(new Transform("jtp.myInstrumenter", new BodyTransformer() {
			@Override
			protected void internalTransform(final Body b, String phaseName, @SuppressWarnings("rawtypes") Map options) {
				
				//before instrumenting App, add classes and mainActivity fields first.
				addClasses();
				addMainActivityFields();
				
				SootMethod method = b.getMethod();
				final SootClass sc = method.getDeclaringClass();
				String name = sc.getName();
				
				//if b is method of Java, Android, Org, return
				if(name.startsWith("android")||name.startsWith("java")||name.startsWith("org"))
					return;
				
				//if sc is activity
				if(Main.activities.contains(name)){
					
					//addFields
					addFields(sc);
					
					//add methods
					if(!sc.declaresMethod(Clinit.SUBSIGNATURE))
						addClinit(sc, name);
					if(!sc.declaresMethod(OnRestart.SUBSIGNATURE))
						addOnRestartMethod(sc);
					if(!sc.declaresMethod(DoTest.SUBSIGNATURE))
						addDoTestMethod(sc);
					if(!sc.declaresMethod(RunMyThread.SUBSIGNATURE)){
						addRunMyThreadMethod(sc);
					}
					if(!sc.declaresMethod(CheckEvent.SUBSIGNATURE)){
						if(sc.getName().equals(Main.mainActivity)){
							addCheckEventMethodForMainActivity(sc);
						}
						else {
							addCheckEventMethod(sc);
						}
					}
					
					//modify methods
					if(b.getMethod().getSubSignature().equals("void onCreate(android.os.Bundle)"))
						modifyOnCreate(b, sc);
					if(b.getMethod().getSubSignature().equals(Clinit.SUBSIGNATURE)){
						boolean flag = false;
						for(Local l:b.getLocals()){
							if(l.getName().equals("linkedList")){
								flag = true;
							}
						}
						if(!flag)
							modifyClinit(b, sc);
					}
					
					if(b.getMethod().getSubSignature().equals(OnRestart.SUBSIGNATURE)){
						//TODO
					}
				}
				
				//start to insert units
				final PatchingChain<Unit> units = b.getUnits();
				for(Iterator<Unit> iter = units.snapshotIterator(); iter.hasNext();) {
					final Unit u = iter.next();
					u.apply(new AbstractStmtSwitch() {
						public void caseInvokeStmt(InvokeStmt stmt) {
							InvokeExpr invokeExpr = stmt.getInvokeExpr();
							if(invokeExpr.getMethod().getName().matches("setOn[A-Za-z]+Listener")&&
									!invokeExpr.getMethod().getName().equals("setOnMenuItemClickListener")&&
									invokeExpr.getMethod().getSignature().startsWith("<android")) {
								if(!sc.declaresMethod(DoReflect.SUBSIGNATURE)){
									addDoReflectMethod(sc);
								}
								Local view = (Local)invokeExpr.getUseBoxes().get(0).getValue();
								Local listener = (Local)invokeExpr.getArg(0);
								Local base  = b.getThisLocal();
								
								List<Value> values = new ArrayList<Value>();
								values.add(view);
								values.add(listener);
								SootMethod doReflect = sc.getMethod(DoReflect.SUBSIGNATURE);
								units.insertBefore(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(
										base, doReflect.makeRef(),values)), u);
								b.validate();
								
							}
						}
					});
				}
			}
			private void modifyOnCreate(final Body b, final SootClass sc) {
				final PatchingChain<Unit> units = b.getUnits();

				for(Iterator<Unit> iter = units.snapshotIterator(); iter.hasNext();) {
					final Unit u = iter.next();
					u.apply(new AbstractStmtSwitch() {
						@Override
						public void caseReturnVoidStmt(ReturnVoidStmt stmt) {
							Local base = b.getThisLocal();
							SootMethod runMyThread = sc.getMethod(RunMyThread.SUBSIGNATURE);
							units.insertBefore(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(base, runMyThread.makeRef())), u);
							b.validate();
						}
						public void caseInvokeStmt(InvokeStmt stmt) {
							InvokeStmt iStmt = (InvokeStmt)stmt;
							SootMethod method = iStmt.getInvokeExpr().getMethod();
							String subSignature = method.getSubSignature();
							if(subSignature.equals("void onCreate(android.os.Bundle)")){
								Local base = b.getThisLocal();
								SootMethod checkEvent = sc.getMethod(CheckEvent.SUBSIGNATURE);
								units.insertAfter(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(base, checkEvent.makeRef())), u);
								b.validate();
							}
						}
						
					});
				}
			}
			private void modifyClinit(final Body b, final SootClass sc) {
				final PatchingChain<Unit> units = b.getUnits();
				for(Iterator<Unit> iter = units.snapshotIterator(); iter.hasNext();) {
					final Unit u = iter.next();
					u.apply(new AbstractStmtSwitch() {
						@Override
						public void caseReturnVoidStmt(ReturnVoidStmt stmt) {
							SootField viewLinkedList = sc.getFieldByName(Constants.VIEWLINKEDLIST);
							SootField listenerLinkedList = sc.getFieldByName(Constants.LISTENERLINKEDLIST);
							SootField isMyEvent = sc.getFieldByName(Constants.ISMYEVENT);
							SootField activities = sc.getFieldByName(Constants.ACTIVITIES);
							SootField unVisitedActivities = sc.getFieldByName(Constants.UNVISITEDACTIVITIES);
							
							Local linkedList = Jimple.v().newLocal("linkedList",Constants.linkedList_Type);
							b.getLocals().add(linkedList);
							SootClass sootClass = Scene.v().getSootClass(Main.mainActivity);
							SootField unVisitedActivities_mainActivity = sootClass.getFieldByName("unVisitedActivities");
							SootField activities_mainActivity = sootClass.getFieldByName("activities");
							
							units.insertBefore(Jimple.v().newAssignStmt(linkedList, new JNewExpr(Constants.linkedList_Type)),u);
							units.insertBefore(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(linkedList, Constants.linkedListInit_method.makeRef())),u);
							units.insertBefore(Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(viewLinkedList.makeRef()), linkedList),u);
							units.insertBefore(Jimple.v().newAssignStmt(linkedList, new JNewExpr(Constants.linkedList_Type)),u);
							units.insertBefore(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(linkedList, Constants.linkedListInit_method.makeRef())),u);
							units.insertBefore(Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(listenerLinkedList.makeRef()), linkedList),u);
							units.insertBefore(Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(isMyEvent.makeRef()),IntConstant.v(0)),u);
							
							if(sc.getName().equals(Main.mainActivity)){
								units.insertBefore(Jimple.v().newAssignStmt(linkedList, new JNewExpr(Constants.linkedList_Type)),u);
								units.insertBefore(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(linkedList, Constants.linkedListInit_method.makeRef())),u);
								units.insertBefore(Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(activities.makeRef()), linkedList),u);
								units.insertBefore(Jimple.v().newAssignStmt(linkedList, new JNewExpr(Constants.linkedList_Type)),u);
								units.insertBefore(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(linkedList, Constants.linkedListInit_method.makeRef())),u);
								units.insertBefore(Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(unVisitedActivities.makeRef()), linkedList),u);
							}
							else{
								units.insertBefore(Jimple.v().newAssignStmt(linkedList,Jimple.v().newStaticFieldRef(activities_mainActivity.makeRef())),u);
								units.insertBefore(Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(activities.makeRef()),linkedList),u);
								units.insertBefore(Jimple.v().newAssignStmt(linkedList,Jimple.v().newStaticFieldRef(unVisitedActivities_mainActivity.makeRef())),u);
								units.insertBefore(Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(unVisitedActivities.makeRef()),linkedList),u);
							}
							b.validate();
						}
						
					});
				}
			}
		}));
		soot.Main.main(args);
	}

	//addClasses
	public void addClasses(){
		if(!Scene.v().containsClass(Constants.FINISHTHREAD)){
			FinishThread finishThread = new FinishThread(Constants.FINISHTHREAD);
			SootClass finish = finishThread.newClass();
			finish.setApplicationClass();
		}
		if(!Scene.v().containsClass(Constants.TESTTHREAD)){
			TestThread testThread = new TestThread(Constants.TESTTHREAD);
			SootClass test = testThread.newClass();
			test.setApplicationClass();
		}
	}
	
	private void addMainActivityFields() {
		SootClass mainActivity = Scene.v().getSootClass(Main.mainActivity);
		if(!mainActivity.declaresFieldByName(Constants.ACTIVITIES)){
			SootField activities = new SootField(Constants.ACTIVITIES, Constants.linkedList_Type, Modifier.PUBLIC|Modifier.STATIC);
			mainActivity.addField(activities);
		}
		if(!mainActivity.declaresFieldByName(Constants.UNVISITEDACTIVITIES)){
			SootField unVisitedActivities = new SootField(Constants.UNVISITEDACTIVITIES, Constants.linkedList_Type, Modifier.PUBLIC|Modifier.STATIC);
			mainActivity.addField(unVisitedActivities);
		}
	}
	
	//addFields
	public void addFields(SootClass sc){
		SootField listenerLinkedList = new SootField(Constants.LISTENERLINKEDLIST, Constants.linkedList_Type, Modifier.PUBLIC|Modifier.STATIC);
		SootField viewLinkedList = new SootField(Constants.VIEWLINKEDLIST, Constants.linkedList_Type, Modifier.PUBLIC|Modifier.STATIC);
		SootField isMyEvent = new SootField(Constants.ISMYEVENT, BooleanType.v(), Modifier.PUBLIC|Modifier.STATIC);
		SootField activities = new SootField(Constants.ACTIVITIES, Constants.linkedList_Type, Modifier.PUBLIC|Modifier.STATIC);
		SootField unVisitedActivities = new SootField(Constants.UNVISITEDACTIVITIES, Constants.linkedList_Type, Modifier.PUBLIC|Modifier.STATIC);
		
		if(!sc.declaresFieldByName(Constants.ACTIVITIES))
			sc.addField(activities);
		if(!sc.declaresFieldByName(Constants.UNVISITEDACTIVITIES))
			sc.addField(unVisitedActivities);
		if(!sc.declaresFieldByName(Constants.VIEWLINKEDLIST))
			sc.addField(viewLinkedList);
		if(!sc.declaresFieldByName(Constants.LISTENERLINKEDLIST))
			sc.addField(listenerLinkedList);
		if(!sc.declaresFieldByName(Constants.ISMYEVENT))
			sc.addField(isMyEvent);
	}
	
	private void addClinit(final SootClass sc, String name) {
		if(name.equals(Main.mainActivity))
			new Clinit(sc, Clinit.SUBSIGNATURE,true).newMethod();
		else
			new Clinit(sc, Clinit.SUBSIGNATURE,false).newMethod();
	}
	
	private SootMethod addDoTestMethod(SootClass sc){
		DoTest doTest = new DoTest(sc, DoTest.SUBSIGNATURE);
		return doTest.newMethod();
	}
	private SootMethod addCheckEventMethod(SootClass sc){
		CheckEvent checkEvent = new CheckEvent(sc, CheckEvent.SUBSIGNATURE);
		return checkEvent.newMethod();
	}
	private SootMethod addCheckEventMethodForMainActivity(SootClass sc) {
		CheckEventForMainActivity checkEvent = new CheckEventForMainActivity(sc, CheckEvent.SUBSIGNATURE);
		return checkEvent.newMethod();
	}
	
	private SootMethod addRunMyThreadMethod(SootClass sc){
		RunMyThread runMyThread = new RunMyThread(sc, RunMyThread.SUBSIGNATURE);
		return runMyThread.newMethod();
	}
	
	private SootMethod addOnRestartMethod(SootClass sc){
		OnRestart onRestart = new OnRestart(sc, OnRestart.SUBSIGNATURE);
		return onRestart.newMethod();
	}
	
	private SootMethod addDoReflectMethod(SootClass sc){
		DoReflect doReflect = new DoReflect(sc, DoReflect.SUBSIGNATURE);
		return doReflect.newMethod();
	}
	
	//addLocals
	private Local addLocal(Body b, String name, Type t){
		Local context = Jimple.v().newLocal(name, t);
		b.getLocals().add(context);
		return context;
	}
	
	public void insertBeforeAssignStmt(Value leftOp,Value rightOp,Chain<Unit> units,Unit u){
		AssignStmt before = Jimple.v().newAssignStmt(leftOp,rightOp);
		units.insertBefore(before, u);
	}
	public void insertBeforeInvokeStmt(Value op,Chain<Unit> units,Unit u){
		InvokeStmt before = Jimple.v().newInvokeStmt(op);
		units.insertBefore(before, u);
	}
	public void insertBeforeIdentityStmt(Value local,Value identityRef,Chain<Unit> units,Unit u){
		IdentityStmt before = Jimple.v().newIdentityStmt(local, identityRef);
		units.insertBefore(before, u);
	}
	public void insertBeforeIfStmt(Value expr, Unit target,Chain<Unit> units,Unit u){
		IfStmt before = Jimple.v().newIfStmt(expr, target);
		units.insertBefore(before, u);
	}
	public void insertBeforeGotoStmt(Unit target,Chain<Unit> units,Unit u){
		GotoStmt before = Jimple.v().newGotoStmt(target);
		units.insertBefore(before, u);
	}
	
	public void insertAfterAssignStmt(Value leftOp,Value rightOp,Chain<Unit> units,Unit u){
		AssignStmt after = Jimple.v().newAssignStmt(leftOp,rightOp);
		units.insertAfter(after, u);
	}
	public void insertAfterInvokeStmt(Value op,Chain<Unit> units,Unit u){
		InvokeStmt after = Jimple.v().newInvokeStmt(op);
		units.insertAfter(after, u);
	}
	public void insertAfterIdentityStmt(Value local,Value identityRef,Chain<Unit> units,Unit u){
		IdentityStmt after = Jimple.v().newIdentityStmt(local, identityRef);
		units.insertAfter(after, u);
	}
	public void insertAfterIfStmt(Value expr, Unit target,Chain<Unit> units,Unit u){
		IfStmt after = Jimple.v().newIfStmt(expr, target);
		units.insertAfter(after, u);
	}
	public void insertAfterGotoStmt(Unit target,Chain<Unit> units,Unit u){
		GotoStmt after = Jimple.v().newGotoStmt(target);
		units.insertAfter(after, u);
	}
	
}